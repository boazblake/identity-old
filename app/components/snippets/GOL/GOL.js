export const GOL ="const Stream  = m.stream\nconst compose = R.compose\nconst range = R.range\nconst without = R.without\nconst values = R.values\nconst prop = R.prop\nconst root = document.getElementById('GameOfLife')\nconst SIBLINGCOORDS = [[-1, 0],[-1, 1],[0, 1],[1, 1],[1, 0],[1, -1],[0, -1],[-1, -1]]\nconst log = m => v => {console.log(m,v); return v}\n\nconst model = {\n  isRunning: Stream(false),\n  board: [],\n  cells:[],\n  boardArray: [],\n  delay: Stream(300),\n  size: Stream(10),\n  width: Stream(1000),\n  generation: Stream(0)\n}\n\nconst restart = (mdl) => {\n  mdl.isRunning(false)\n  mdl.delay(300)\n  mdl.size(10)\n  mdl.width(1000)\n  mdl.generation(0)\n  mdl.board = []\n  mdl.cells = []\n  mdl.boazrdArray = []\n  return mdl\n}\n\nconst withinBounds = (limit) => (coords) => \n  !(coords.includes(limit) || coords.includes(-1))\n  \n\nconst toSiblings = mdl =>(limit) => (sibCoords) => (coords) =>\n  sibCoords\n    .map((sib) => [sib[0] + coords[0], sib[1] + coords[1]])\n    .filter(withinBounds(limit))\n\nconst makeCell = (mdl) => (size) => (key) => {\n  let coords = [key % size, Math.floor(key / size)]\n  let siblings = toSiblings(mdl)(size)(SIBLINGCOORDS)(coords)\n  let cell = {\n    key,\n    rowIdx: null,\n    idx: null,\n    value: '',\n    isAlive: false,\n    coords: coords.toString(),\n    siblings: siblings.map(s => s.toString())\n  }\n  return cell\n}\n\nconst makeMatrix = (width, xs) =>\n    xs.reduce((rows, key, index) => (index % width == 0 ? rows.push([key]) \n      : rows[rows.length-1].push(key)) && rows, []);\n\nconst createMatrix = mdl => {\n  let cellsArray = range(0, mdl.size() * mdl.size()).map(makeCell(mdl)(mdl.size()))\n  mdl.board = makeMatrix(mdl.size(), cellsArray)\n  return mdl\n}\n \nconst initGame = ({attrs:{mdl}}) => createMatrix(mdl)\n \nconst makeNewGame = compose(createMatrix,restart)\n \nconst calcNextPhase = (mdl) => {\n  let cellsArray = R.flatten(mdl.board)\n  let cells =  cellsArray.reduce(\n    (acc, cell) => {\n      acc[cell.coords] = cell.isAlive\n      return acc},{})\n      \n  const getCellByCoord = coord => cells[coord.toString()]\n  \n  cellsArray.map((cell) => {\n    let neighborsAlive =  without([false, undefined],(cell.siblings.map(getCellByCoord)))\n\n    if (cell.isAlive) {\n      if (neighborsAlive.length <= 2) {\n        cell.isAlive = false\n      }\n\n      if ([2, 3].includes(neighborsAlive.length)) {\n        cell.isAlive = true\n      }\n\n      if (neighborsAlive.length > 3) {\n        cell.isAlive = false\n      }\n    } else {\n      if (neighborsAlive.length == 3) {\n        p(cell, neighborsAlive)\n        cell.isAlive = true\n      }\n    }\n  })\n  return mdl\n}\n\nconst runGOL = (mdl) => {\n  if (mdl.isRunning()) {\n    mdl.generation(mdl.generation() + 1)\n    setTimeout(() => {\n      m.redraw()\n      return runGOL(calcNextPhase(mdl))\n    }, mdl.delay())\n  } else {\n    return mdl\n  }\n}\n\nconst advanceLifeCycle = mdl => (e) => {\n  mdl.isRunning(false)\n  mdl.generation(mdl.generation() + 1)\n  calcNextPhase(mdl)\n}\n\nconst goForth = mdl => (e) => {\n  mdl.isRunning(true)\n  runGOL(mdl)\n}\n\nconst setDelay = mdl => (e) => mdl.delay(e.target.value)\n\nconst setBoardSize = mdl => (e) => {\n  mdl.size(e.target.value)\n  initGame({attrs:{mdl}})\n}\n\nconst Cell = {\n  view: ({ attrs: {rowIdx, idx, mdl, cell } }) =>  m('td.cell', {\n      class: cell.isAlive ? 'alive' : 'dead',\n      style: {\n        fontSize: `${mdl.width() / mdl.size() / 2}px`,\n        height: `${mdl.width() / mdl.size() / 2}px`,\n        flex: `1 1 ${mdl.width() / mdl.size() / 2}px`\n      },\n      onclick: () => mdl.board[rowIdx][idx].isAlive = !cell.isAlive\n    })\n}\n\nconst Board = ({ attrs: { mdl } }) => {\n  return {\n    view: ({ attrs: { mdl } }) =>   \n      m('Table.board',\n        { style: { width: `${mdl.width()}px` } },\n        mdl.board.map((row, rowIdx) =>\n        m('tr', row.map((coord, idx) => \n          {\n            let cell = mdl.board[rowIdx][idx]\n            cell.idx = idx\n            cell.rowIdx = rowIdx\n        return m(Cell, {rowIdx, idx, cell, key: cell.key, mdl })\n      }\n   ))))\n  }\n}\n\nconst Input = () => {\n  return {\n    view: ({ attrs: { mdl, label, min, max, step, value, fn } }) => [\n      m('label', [label,\n      m('input', {\n        inputmode: 'numeric',\n        pattern:'[0-9]*',\n        type: 'number',\n        min,\n        max,\n        step,\n        value,\n        oninput: e => fn(e)\n      })\n      ])\n    ]\n  }\n}\n\nconst Button = () => {\n  return {\n    view:({attrs:{mdl, label, fn}}) => m(\n        'button', {onclick: (e) => fn(e)},\n        label\n      )\n  }\n}\n\nconst TopRow = {\n  view:({attrs:{mdl}})=>\n   m('.topRow', [m(Button, {mdl, fn:() => makeNewGame(mdl), label: 'Restart'}),\n      m(Button, {mdl, fn: advanceLifeCycle(mdl), label:'Advance 1 Generation'}),\n      m(Button, {mdl, fn:goForth(mdl), label:'Go Forth'})])\n}\n\nconst BottomRow = {\n  view:({attrs:{mdl}})=>\n    m('.bottomRow',[\n      m(Input, { mdl, label: 'Delay(ms):', min:0, max:1000, step:100, value:mdl.delay(), fn:setDelay(mdl) }),\n      m(Input, { mdl, label: 'size:', min:10, max:100, step:10, value:mdl.size(), fn: setBoardSize(mdl) })])\n}\n \nconst Toolbar = {\n  view: ({ attrs: { mdl } }) =>\n    m('.toolbar', [\n      m(TopRow, {mdl}),\n      m(BottomRow, {mdl})\n    ])\n}\n\nconst GameOfLife = {\n  oninit: initGame,\n  view: ({ attrs: { mdl } }) => {\n    return m('.container', [\n      m(Toolbar, { mdl }),\n      m(Board, { mdl }),\n      m('h2', `generation: ${mdl.generation()}`)\n    ])\n  }\n}\n\nm.mount(root, {view:() => m(GameOfLife, {mdl:model})})"
