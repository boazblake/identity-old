export const GOL =
  "const compose = R.compose\nconst flatten = R.flatten\nconst range = R.range\nconst without = R.without\nconst values = R.values\nconst prop = R.prop\nconst root = document.getElementById('GameOfLife')\nconst log = m => v => {console.log(m,v); return v}\n\nconst SIBLING_COORDS = [[-1, 0],[-1, 1],[0, 1],[1, 1],[1, 0],[1, -1],[0, -1],[-1, -1]]\n\nconst model = {\n  isRunning: false, \n  matrix: [],\n  delay: 300,\n  size: 10,\n  width: 1000,\n  generation: 0\n}\n\nconst restart = (mdl) => {\n  mdl.isRunning = false\n  mdl.delay = 300\n  mdl.size = 10\n  mdl.width = 1000\n  mdl.generation = 0\n  mdl.matrix = []\n  return mdl\n}\n\nconst withinBounds = (limit) => (coords) => \n  !(coords.includes(limit) || coords.includes(-1))\n  \nconst toSiblings = (limit) => (sibCoords) => (coords) =>\n  sibCoords\n\t.map((sib) => [sib[0] + coords[0], sib[1] + coords[1]])\n\t.filter(withinBounds(limit))\n\nconst toCell = (key, size, rowIdx, idx) =>  {\n  let coords = [key % size, Math.floor(key / size)]\n  let siblings = toSiblings(size)(SIBLING_COORDS)(coords)\n  return {\n\tkey,\n\trowIdx,\n\tidx,\n\tvalue: '',\n\tisAlive: false,\n\tcoords: coords.toString(),\n\tsiblings: siblings.map(s => s.toString())\n  }\n}\nconst makeMatrix = (width, xs) =>\n\txs.reduce((rows, key, index) => \n\t  (index % width == 0 \n\t\t? rows.push([key]) \n\t\t: rows[rows.length-1].push(key)) && rows, \n\t  []);\n\nconst createMatrix = mdl => {\n  let cellsArray = range(0, mdl.size * mdl.size)\n  let cellsMatrix = makeMatrix(mdl.size, cellsArray)\n  mdl.matrix = cellsMatrix.map((row, rowIdx) => \n\trow.map((key, idx) => \n\t  toCell(key, mdl.size, rowIdx, idx)))\n  return mdl\n}\n \nconst initGame = ({attrs:{mdl}}) => createMatrix(mdl)\n \nconst makeNewGame = compose(createMatrix,restart)\n \nconst calcNextPhase = (mdl) => {\n  let cellsArray = flatten(mdl.matrix)\n  let cells =  cellsArray.reduce((acc, cell) => {\n\t  acc[cell.coords] = cell.isAlive\n\t  return acc},{})\n\t  \n  const getCellByCoord = coord => cells[coord.toString()]\n  \n  cellsArray.map((cell) => {\n\tlet neighborsAlive =  without([false, undefined],(cell.siblings.map(getCellByCoord)))\n\n\tif (cell.isAlive) {\n\t  if (neighborsAlive.length <= 2) {\n\t\tcell.isAlive = false\n\t  }\n\n\t  if ([2, 3].includes(neighborsAlive.length)) {\n\t\tcell.isAlive = true\n\t  }\n\n\t  if (neighborsAlive.length > 3) {\n\t\tcell.isAlive = false\n\t  }\n\t} else {\n\t  if (neighborsAlive.length == 3) {\n\t\tcell.isAlive = true\n\t  }\n\t}\n  })\n  return mdl\n}\n\nconst runGOL = (mdl) => {\n  if (mdl.isRunning) {\n\tmdl.generation = mdl.generation++\n\tsetTimeout(() => {\n\t  m.redraw()\n\t  return runGOL(calcNextPhase(mdl))\n\t}, mdl.delay )\n  } else {\n\treturn mdl\n  }\n}\n\nconst advanceLifeCycle = mdl => (e) => {\n  mdl.isRunning = false\n  mdl.generation++\n  calcNextPhase(mdl)\n}\n\nconst goForth = mdl => (e) => {\n  mdl.isRunning = true\n  runGOL(mdl)\n}\n\nconst setDelay = mdl => (e) => mdl.delay = e.target.value\n\nconst setMatrixSize = mdl => (e) => {\n  mdl.size = e.target.value\n  createMatrix(mdl)\n}\n\nconst Cell = {\n  view: ({ attrs: {mdl, cell } }) =>  m('td.cell', {\n\t  class: cell.isAlive ? 'alive' : 'dead',\n\t  style: {\n\t\tfontSize: `${mdl.width / mdl.size}px`,\n\t\theight: `${mdl.width / mdl.size }px`,\n\t\tflex: `1 1 ${mdl.width / mdl.size}px`\n\t  },\n\t  onclick: () => mdl.matrix[cell.rowIdx][cell.idx].isAlive = !cell.isAlive\n\t})\n}\n\nconst Matrix = {\n  view: ({ attrs: { mdl } }) =>   \n\tm('Table.matrix',\n\t  { style: { width: `${mdl.width}px` } },\n\t  mdl.matrix.map((row, rowIdx) =>\n\t  m('tr', row.map((coord, idx) => \n\t   m(Cell, { mdl, cell:mdl.matrix[rowIdx][idx] }) ))))\n}\n\nconst Input =  {\n  view: ({ attrs: { mdl, label, min, max, step, value, fn } }) => [\n\tm('label', [label,\n\tm('input', {\n\t  inputmode: 'numeric',\n\t  pattern:'[0-9]*',\n\t  type: 'number',\n\t  min,\n\t  max,\n\t  step,\n\t  value,\n\t  oninput: e => fn(e)\n\t})\n\t])\n  ]\n}\n\nconst Button = {\n  view:({attrs:{mdl, label, fn}}) => \n\tm('button', {onclick: (e) => fn(e)}, label)\n}\n\nconst TopRow = {\n  view:({attrs:{mdl}})=>\n   m('.topRow', [m(Button, {mdl, fn:() => makeNewGame(mdl), label: 'Restart'}),\n\t  m(Button, {mdl, fn: advanceLifeCycle(mdl), label:'Advance 1 Generation'}),\n\t  m(Button, {mdl, fn:goForth(mdl), label:'Go Forth'})])\n}\n\nconst BottomRow = {\n  view:({attrs:{mdl}})=>\n\tm('.bottomRow',[\n\t  m(Input, { mdl, label: 'Delay(ms):', min:0, max:1000, step:100, value:mdl.delay, fn:setDelay(mdl) }),\n\t  m(Input, { mdl, label: 'size:', min:10, max:1000, step:10, value:mdl.size, fn: setMatrixSize(mdl) })])\n}\n \nconst Toolbar = {\n  view: ({ attrs: { mdl } }) =>\n\tm('.toolbar', [\n\t  m(TopRow, {mdl}),\n\t  m(BottomRow, {mdl})\n\t])\n}\n\nconst GameOfLife = {\n  oninit: initGame,\n  view: ({ attrs: { mdl } }) => {\n\treturn m('.container', [\n\t  m(Toolbar, { mdl }),\n\t  m(Matrix, { mdl }),\n\t  m('h2', `generation: ${mdl.generation}`)\n\t])\n  }\n}\n\nm.mount(root, {view:() => m(GameOfLife, {mdl:model})})"
